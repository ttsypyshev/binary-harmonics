import random

# Исходный "битовый" текст
# (Я не заморачивался и сделал его не битовым, но по идее это должен быть файл в двоичном представлении)
# text = "1010111111"
text = ''.join(random.choice('01') for _ in range(1000))
print("Исходный текст:", text)

# Массив с текстом и соответствующими ему флагами
# (Флаг используется для того, чтобы пропускать при поиске уже отмеченные гармоникой биты и не создавать лишние гармоники)
text_check = [(char, False) for char in text]

# Мапа гармоник, где гармоника — это какое-то чередование, где начиная с i с шагом step по тексту будут только единицы
harmonics = {}  # i: step

n = len(text)
for i in range(n):
    # Проходимся по всем "неотмеченным" единицам
    if (text_check[i][0] == "1" and text_check[i][1] == False):
        for step in range(1, n):
            # Перебираем шаг до первой возможной гармоники
            # (Чтобы все биты текста, начиная с i % step с шагом step, были 1)
            if all(text[j] == "1" for j in range(i % step, n, step)):
                # Помечаем биты из этой гармоники как использованные
                for idx in range(i % step, n, step):
                    text_check[idx] = (text_check[idx][0], True)
                # Сохраняем эту гармонику
                harmonics.setdefault(i % step, set()).add(step)
                break
        # Если не нашли гармонику, то сохраняем как "единичную" гармонику
        # (Не получается создать гармонику с этой значащей единицей, так чтобы попадала ещё одна 1 и не попадал 0)
        # Например, при text = 00000001
        else:
            text_check[i] = (text_check[i][0], True)
            harmonics.setdefault(i, set()).add(n - i)

# Перепроверка на оставшиеся единицы
for char in text_check:
    if (char[0] == "1" and char[1] == False):
        print("ERROR!!!")

# Подсчёт общего количества гармоник
total_harmonics = sum(len(steps) for steps in harmonics.values())
print("Итоговые гармоники:", harmonics)
print("Общее количество гармоник:", total_harmonics)

# Будет ли эффективен этот алгоритм для сжатия случайного набора информации на огромных масштабах?
# Можно ли использовать этот метод для приведения данных в набор слов для сжатия словарными методами?
# Можно ли оптимизировать этот метод, чтобы он работал на байтах, без конвертации в биты?
# Можно ли переделать этот метод, чтобы он работал в небольших буферах без использования всего битового текста?
# Есть ли зависимость количества гармоник от частоты единиц?
